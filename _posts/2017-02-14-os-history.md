---
title: '聊聊操作系统发展史'
date: 2017-02-14
---

这篇博客主要是想写一写我对操作系统发展历史的学习感悟，主要的参考书目是[Modern Operating Systems 4ed][1]。

## 1945~1955

在20世纪40年代，计算机刚刚出现，采用的硬件一般是真空管（vacuum tubes），甚至连汇编语言都还没有。
使用计算机方式一般是通过把电缆（cable）插到插线板（plugboard）上面来控制计算机的运行。
一般一个程序员会独占几个小时的使用时间，把电缆查好后等待计算结果。
后来虽然出现了卡片（card），可以代码写在卡片上，但使用模式还是没有变化，还是程序员独占几个小时的使用时间。

## 1955~1965

随着晶体管（transistor）的发明，第二代电子计算机出现了。
计算机开始变的稳定、可靠，并真正能用于进行有用的计算。
这个时代的机器叫做大型机（maniframe）。

早些时候，使用大型机的方式是这样的：程序员把代码写在卡片上，交给操作员（operator）。
操作员把卡片读入机器并运行其中的程序，然后把输出结果交给程序员。
这相当于这段时间还是某个程序员独占了这台机器。

这其中一个问题在于，当一个程序员的代码运行完之后，
操作员需要把把输出结果取出（一般打印在纸上），然后再去取另一个输入卡片。
从上一段程序结束到下一段程序开始执行时，机器可能已经空闲了好长时间，这段时间就被浪费了。
因此，最好有一种方法能够让机器能够尽可能地连续运行，不要因为获得输入代码和交付输出结果而浪费机时。

批处理系统（batch system）被用来解决这个问题。
操作员先把多个程序员的卡片收集起来，用一台相对便宜的机器把代码按顺序打在磁带上，作为输入磁带（input tape）。
采用某个昂贵的机器执行程序，把结果输出到另一个磁带（output tape）。
最后再由一个便宜的机器打印输出磁带的结果。
如下图所示（本图来自[Modern Operating Systems 4ed][1]）。

![Git Bash](http://oncob6r5y.bkt.clouddn.com/multi.jpg)

这样的批处理操作系统是操作系统的先驱，并且确实解决了一些问题，但也带来了新的问题。
比如一个程序员的代码如果有错误，他需要等到这一批程序全部运行完了之后能知道。
换句话说，这段时间的机时并不是他独占的。
等程序员修改了程序，可能需要再等待几个小时，才能知道第二次运行程序的结果。

## 1965~1980

这一时段，出现了第三代计算机，即采用中小规模集成电路的电子计算机，它们取代了第二代晶体管计算机。
但是这个时期的计算机是软件不兼容的，换句话说，特定的机器只能运行特定的一部分软件。
例如IBM 7094性能较高，用于运行一些科学计算程序，而IBM 1401只能运行一些归档、打印的程序。

IBM推出了360系列机器来解决这个问题。360是一系列软件兼容的机器。
为了让一系列的机器能够运行各种不同的软件，就催生了OS/360操作系统。
这个操作系统规模庞大，编写困难，其设计者Fred Brooks专门写了一本书来描述编写OS/360中遇到的困难，就是著名的《人月神话》。

![Git Bash](http://oncob6r5y.bkt.clouddn.com/multicsroad.jpg)

OS/360第一次提出了多道程序设计的概念（multiprogramming），允许在内存中载入多个程序，如上图所示。
当一个程序在IO时，CPU可以运行另一个程序，从而把CPU的利用率提升到接近100%。
内存中驻留多个程序需要特殊的硬件给于保护，OS/360运行的硬件上都配备有这样的硬件。

此外，OS/360使用SPOOLING（simultaneous peripheral operation on line）技术来加快IO速度，
能够快速地把作业从卡片读入磁盘，从而在需要时快速地调入内存，这样就不再需要1404机器了。

OS/360系统本质上还是批处理系统，因此也有跟批处理系统同样的问题——程序员不能独占机时，因此不能及时发现程序错误。
这种问题由分时系统（timesharing system）负责解决。每个用户有一个终端（terminal），用户通过终端登录到机器，
机器为所有终端用户的命令（command）提供快速的响应的服务。
第一个分时系统叫做CTSS（compatible time sharing system），由MIT开发。

在CTSS之后，MIT、Bell实验室和通用电气公司开始联合开发一个叫做MULTICS（multiplexed information and computing service）的系统。
MULTICS的目标是像电力系统一样提供计算服务，当用户用电时只需要插上插头，而需要计算服务时只需要登录一个终端，
这种思想在当时毫无疑问是超前的（想想今天的云计算服务）。
开发MULTICS的工作最终只有MIT坚持了下来，并商业化，但结果并不是非常成功，
真正使用它的用户并不多，远没有达到为整座城市提供计算服务的设想。

MULTICS对后来的操作系统产生了深远的影响，包括UNIX、Linux等等。
一个参与过MULTICS的人编写了UNIX，成为了直到今天仍然广泛使用的操作系统。
UNIX主要有两个版本，分别是来自AT&T的system V，以及BSD的版本。
为了让多个UNIX变种支持大家写的代码，IEEE提出了POSIX标准来统一UNIX的接口。
现在Linux和Windows实际上都支持POSIX接口。

1987年，出现了一个UNIX的一个变种，即MINIX，其作者就是[Modern Operating Systems 4ed][1]的作者Andrew。
MINIX采用了微内核架构进行设计和实现，因此具备高度模块化、可靠的特性。
后来，芬兰学生Linus Torvalds编写了Linux，后面的故事我想大家都应该知道了。

## 1980~present

这一时代对应的硬件是第四代计算机——大规模集成电路计算机。
得益于大规模集成电路，每个人都拥有一个个人的计算机成为可能，也就是所谓的PC（personal computer）或者微机（microcomputer）。

Intel最早为8080编写了一个叫做CP/M的操作系统，作者叫做Kildall。
后来Kildall带着CP/M自己成立了软件公司，使得CP/M统治微机界长达5年。

在1980s，IBM设计了IBM PC，即IBM的个人电脑系列。为了寻找在IBM PC上的操作系统，
IBM联系Kildall，然而后者居然拒绝为IBM PC提供CP/M。
IBM与比尔盖茨找到了一家公司，感觉它的DOS不错，便吸引到了它的微软公司中。
盖茨把DOS和IBM PC捆绑在一起，很快DOS就主宰了个人计算机市场。
但DOS和CP/M一样，都是基于字符界面的，对用户友好度非常低下。

胡来，Doug Engelbart发明了图形用户界面，后来被Xerox PARC的研究人员用在了它们的机器中。
苹果公司创始人乔布斯意识到了图形界面的价值，开始开发基于图形界面的苹果计算机。
第一个作品Lisa失败了，但是第二个作品，即著名的Macintosh取得了巨大的成功。
后来，苹果采用Mach微内核作为Mac OS X的内核。这个Mach微内核本来是用来替代BSD UNIX的。
因此苹果的操作系统也是UNIX的一个衍生版本。

看到苹果的成功之后，微软开发了Windows系列操作系统，从最开始的基于DOS的图形界面，
到后来的95、98，以及后来完全重写的32bit的Windwos NT，到Windows Me，到Vista，到7、8和现在的10。

UNIX也在竞争个人计算机市场。其中一个重要变种是FreeBSD。UNIX的变种（例如IOS和Android）广泛应用于现在的移动设备中。
MIT为UNIX开发了图形界面，即X Window System，也叫做X11，在其上可以运行更加完整的桌面系统，例如Gnome或者KDE。

## 总结

通过上文的介绍，我们最后对操作系统的发展历史作如下总结：

- （真空管计算机）没有操作系统的时候，每个程序员独占机器，插电缆或者打卡片，然后等待结果。问题是浪费机时比较多。
- （晶体管计算机）出现了批处理系统，解决机器不能连续运行，浪费机时的问题。但是程序员不能独占机器，不能得到错误反馈，交互性变得很差。
- （中小规模集成电路）OS/360统一了软件运行环境，提出了多道程序设计，并采用了SPOOLING技术，但没有解决交互性问题。
- （中小规模集成电路）CTSS和MULTICS为代表的分时操作系统，解决用户交互性问题。UNIX、MINIX、Linux出现。
- （大规模集成电路，个人计算机）CP/M、DOS等字符界面的机器。苹果的Lisa和Macintosh是第一个有图形界面的个人计算机。微软的Windows系列。UNIX的X11等等。


[1]: https://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X/ref=sr_1_1?ie=UTF8&qid=1487074667&sr=8-1&keywords=modern+operating+systems 'Modern Operating Systems'
